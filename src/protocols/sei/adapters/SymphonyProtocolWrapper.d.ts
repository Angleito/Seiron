import * as TE from 'fp-ts/TaskEither';
import { PublicClient, WalletClient } from 'viem';
import { SymphonyConfig, SymphonyError, SwapQuoteRequest, SwapQuoteResponse, SwapExecuteRequest, SwapExecuteResponse, RouteRequest, RouteResponse, GasEstimateRequest, GasEstimateResponse, SwapValidationResponse, SwapAnalytics, ProtocolStats, SwapImpactAnalysis, OptimalRouteAnalysis, SwapMonitoring, SymphonyIntegrationConfig, CrossProtocolRoute, RouteOptimizationParams } from '../types';
export declare class SymphonyProtocolWrapper {
    private config;
    private integrationConfig;
    private publicClient;
    private walletClient;
    private quoteCache;
    private routeCache;
    constructor(config: SymphonyConfig, integrationConfig: SymphonyIntegrationConfig, publicClient: PublicClient, walletClient: WalletClient);
    getQuote: (request: SwapQuoteRequest) => TE.TaskEither<SymphonyError, SwapQuoteResponse>;
    executeSwap: (request: SwapExecuteRequest) => TE.TaskEither<SymphonyError, SwapExecuteResponse>;
    getRoutes: (request: RouteRequest) => TE.TaskEither<SymphonyError, RouteResponse>;
    estimateGas: (request: GasEstimateRequest) => TE.TaskEither<SymphonyError, GasEstimateResponse>;
    validateSwap: (request: SwapExecuteRequest) => TE.TaskEither<SymphonyError, SwapValidationResponse>;
    analyzeSwapImpact: (request: SwapQuoteRequest) => TE.TaskEither<SymphonyError, SwapImpactAnalysis>;
    findOptimalRoute: (request: RouteRequest, params: RouteOptimizationParams) => TE.TaskEither<SymphonyError, OptimalRouteAnalysis>;
    getCrossProtocolRoutes: (request: RouteRequest) => TE.TaskEither<SymphonyError, CrossProtocolRoute[]>;
    getAnalytics: () => TE.TaskEither<SymphonyError, SwapAnalytics>;
    getProtocolStats: () => TE.TaskEither<SymphonyError, ProtocolStats>;
    monitorSwap: (txHash: string) => TE.TaskEither<SymphonyError, SwapMonitoring>;
    private generateCacheKey;
    private getCachedQuote;
    private getCachedRoutes;
    private cacheQuote;
    private cacheRoutes;
    private fetchQuote;
    private fetchRoutes;
    private fetchGasEstimate;
    private fetchAnalytics;
    private fetchProtocolStats;
    private fetchTransactionStatus;
    private validateSwapRequest;
    private validateGasEstimateRequest;
    private validateQuote;
    private validateGasEstimate;
    private checkTokenAllowances;
    private estimateGasForSwap;
    private performSwap;
    private monitorSwapExecution;
    private validateTokenLiquidity;
    private validateSlippageSettings;
    private validateGasSettings;
    private calculatePriceImpact;
    private assessRisk;
    private generateRecommendations;
    private optimizeRoutes;
    private analyzeRoutes;
    private scoreRoutes;
    private selectOptimalRoute;
    private fetchCrossProtocolRoutes;
    private validateCrossProtocolRoutes;
    private rankCrossProtocolRoutes;
    private validateAnalytics;
    private enrichAnalytics;
    private validateProtocolStats;
    private enrichProtocolStats;
    private trackConfirmations;
    private updateMonitoringStatus;
}
export declare const createSymphonyProtocolWrapper: (config: SymphonyConfig, integrationConfig: SymphonyIntegrationConfig, publicClient: PublicClient, walletClient: WalletClient) => SymphonyProtocolWrapper;
export declare const defaultSymphonyConfig: SymphonyConfig;
export declare const defaultSymphonyIntegrationConfig: SymphonyIntegrationConfig;
//# sourceMappingURL=SymphonyProtocolWrapper.d.ts.map