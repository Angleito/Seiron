<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Fallback Utilities Test</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #111;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 20px;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .test-panel {
            border: 1px solid #00ff00;
            padding: 15px;
            background: rgba(0, 255, 0, 0.05);
        }

        .test-panel h3 {
            margin-top: 0;
            color: #00aaff;
        }

        .test-output {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }

        .controls {
            margin: 10px 0;
        }

        .controls button {
            background: #000;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 8px 16px;
            margin: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .controls button:hover {
            background: rgba(0, 255, 0, 0.1);
        }

        .controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.success { background: #00ff00; }
        .status-indicator.error { background: #ff0000; }
        .status-indicator.warning { background: #ffaa00; }
        .status-indicator.info { background: #00aaff; }

        .context-info {
            background: rgba(0, 102, 255, 0.1);
            border: 1px solid #0066ff;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        .error-info {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        .success-info {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .metrics-table th,
        .metrics-table td {
            border: 1px solid #333;
            padding: 5px;
            text-align: left;
        }

        .metrics-table th {
            background: rgba(0, 255, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔧 WebGL Fallback Utilities Test</h1>
            <p>Direct testing of fallback system utilities and diagnostics</p>
            <p id="load-status">Loading utilities...</p>
        </div>

        <div class="test-grid">
            <div class="test-panel">
                <h3><span class="status-indicator info"></span>Environment Detection</h3>
                <div class="controls">
                    <button onclick="testEnvironmentDetection()">Test Environment</button>
                    <button onclick="testHeadlessDetection()">Test Headless</button>
                </div>
                <div class="test-output" id="environment-output"></div>
            </div>

            <div class="test-panel">
                <h3><span class="status-indicator info"></span>Capability Detection</h3>
                <div class="controls">
                    <button onclick="testCapabilityDetection()">Test Capabilities</button>
                    <button onclick="testThreeJSCompatibility()">Test Three.js</button>
                </div>
                <div class="test-output" id="capability-output"></div>
            </div>

            <div class="test-panel">
                <h3><span class="status-indicator info"></span>Fallback Manager</h3>
                <div class="controls">
                    <button onclick="testFallbackManager()">Create Manager</button>
                    <button onclick="testContextCreation()">Test Contexts</button>
                    <button onclick="disposeFallbackManager()">Dispose</button>
                </div>
                <div class="test-output" id="manager-output"></div>
            </div>

            <div class="test-panel">
                <h3><span class="status-indicator info"></span>Mock Systems</h3>
                <div class="controls">
                    <button onclick="testMockWebGL()">Test Mock WebGL</button>
                    <button onclick="testMockCanvas()">Test Mock Canvas</button>
                    <button onclick="testSoftwareRenderer()">Test Software</button>
                </div>
                <div class="test-output" id="mock-output"></div>
            </div>

            <div class="test-panel">
                <h3><span class="status-indicator info"></span>Diagnostics System</h3>
                <div class="controls">
                    <button onclick="testDiagnostics()">Run Diagnostics</button>
                    <button onclick="testHealthMetrics()">Health Check</button>
                    <button onclick="generateReport()">Full Report</button>
                </div>
                <div class="test-output" id="diagnostics-output"></div>
            </div>

            <div class="test-panel">
                <h3><span class="status-indicator info"></span>Error Recovery</h3>
                <div class="controls">
                    <button onclick="simulateContextLoss()">Simulate Loss</button>
                    <button onclick="testAutoRecovery()">Test Recovery</button>
                    <button onclick="testErrorHandling()">Test Errors</button>
                </div>
                <div class="test-output" id="recovery-output"></div>
            </div>
        </div>

        <div class="test-panel">
            <h3>Real-time Status Monitor</h3>
            <div id="status-monitor">
                <table class="metrics-table">
                    <thead>
                        <tr>
                            <th>Metric</th>
                            <th>Value</th>
                            <th>Status</th>
                            <th>Last Updated</th>
                        </tr>
                    </thead>
                    <tbody id="metrics-tbody">
                        <!-- Metrics will be populated here -->
                    </tbody>
                </table>
            </div>
            <div class="controls">
                <button onclick="startMonitoring()">Start Monitor</button>
                <button onclick="stopMonitoring()">Stop Monitor</button>
                <button onclick="clearMetrics()">Clear</button>
            </div>
        </div>
    </div>

    <!-- Load dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    
    <script type="module">
        // Since we can't import ES modules directly in this test, we'll simulate the utilities
        
        let fallbackManager = null;
        let diagnosticsInstance = null;
        let monitoringInterval = null;
        let testMetrics = {};

        // Simulated WebGL Fallback Manager (simplified version for testing)
        class TestWebGLFallbackManager {
            constructor(config = {}) {
                this.config = {
                    enableSoftwareRendering: true,
                    enableCanvas2DFallback: true,
                    enableHeadlessMode: true,
                    enableMockCanvas: true,
                    fallbackWidth: 800,
                    fallbackHeight: 600,
                    logLevel: 'info',
                    ...config
                };
                
                this.capabilities = null;
                this.currentContext = null;
                this.isHeadless = this.detectHeadless();
                this.isDocker = this.detectDocker();
                this.attemptCount = 0;
                
                this.log('info', 'TestWebGLFallbackManager initialized');
            }

            detectHeadless() {
                return typeof window === 'undefined' || 
                       !window.chrome || 
                       !window.chrome.runtime || 
                       navigator.webdriver === true ||
                       window.navigator.userAgent.includes('HeadlessChrome');
            }

            detectDocker() {
                return window.location.hostname === 'localhost' && !window.devicePixelRatio;
            }

            detectCapabilities() {
                if (this.capabilities) return this.capabilities;

                const caps = {
                    webgl: false,
                    webgl2: false,
                    canvas2d: false,
                    offscreenCanvas: false,
                    headlessMode: this.isHeadless,
                    softwareRendering: false,
                    mockCanvas: false,
                    recommendedMode: 'none'
                };

                if (this.isHeadless) {
                    caps.mockCanvas = this.config.enableMockCanvas;
                    caps.softwareRendering = this.config.enableSoftwareRendering;
                    caps.canvas2d = this.config.enableCanvas2DFallback;
                    caps.recommendedMode = 'mock';
                } else {
                    try {
                        const canvas = document.createElement('canvas');
                        
                        // Test WebGL 2
                        const gl2 = canvas.getContext('webgl2');
                        if (gl2 && !gl2.isContextLost()) {
                            caps.webgl2 = true;
                            caps.webgl = true;
                        }
                        
                        // Test WebGL 1
                        if (!caps.webgl2) {
                            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                            if (gl && !gl.isContextLost()) {
                                caps.webgl = true;
                            }
                        }

                        // Test Canvas 2D
                        const ctx2d = canvas.getContext('2d');
                        if (ctx2d) {
                            caps.canvas2d = true;
                        }

                        canvas.remove();
                    } catch (error) {
                        this.log('error', 'Capability detection error', error);
                    }

                    caps.softwareRendering = caps.canvas2d && this.config.enableSoftwareRendering;
                    caps.mockCanvas = this.config.enableMockCanvas;

                    if (caps.webgl2) {
                        caps.recommendedMode = 'webgl2';
                    } else if (caps.webgl) {
                        caps.recommendedMode = 'webgl';
                    } else if (caps.softwareRendering) {
                        caps.recommendedMode = 'software';
                    } else if (caps.canvas2d) {
                        caps.recommendedMode = 'canvas2d';
                    } else if (caps.mockCanvas) {
                        caps.recommendedMode = 'mock';
                    }
                }

                this.capabilities = caps;
                return caps;
            }

            createContext(mode) {
                const caps = this.detectCapabilities();
                const contextMode = mode || caps.recommendedMode;
                
                const context = {
                    type: contextMode,
                    context: null,
                    canvas: null,
                    renderer: null,
                    capabilities: caps,
                    isHeadless: this.isHeadless,
                    isDocker: this.isDocker,
                    performance: {
                        initTime: 0,
                        renderTime: 0,
                        memoryUsage: 0
                    }
                };

                const startTime = performance.now();

                try {
                    switch (contextMode) {
                        case 'webgl2':
                        case 'webgl':
                            if (this.isHeadless) {
                                throw new Error('WebGL not available in headless mode');
                            }
                            context.canvas = document.createElement('canvas');
                            context.context = context.canvas.getContext(contextMode);
                            if (!context.context) {
                                throw new Error(`Failed to create ${contextMode} context`);
                            }
                            break;
                            
                        case 'canvas2d':
                            context.canvas = this.isHeadless ? this.createMockCanvas() : document.createElement('canvas');
                            context.context = context.canvas.getContext('2d');
                            break;
                            
                        case 'mock':
                        default:
                            context.canvas = this.createMockCanvas();
                            context.context = this.createMockWebGLContext(context.canvas);
                            break;
                    }

                    context.performance.initTime = performance.now() - startTime;
                    this.currentContext = context;
                    this.log('success', `Context created: ${contextMode}`);

                } catch (error) {
                    this.log('error', `Context creation failed: ${contextMode}`, error);
                    if (this.attemptCount < 3) {
                        this.attemptCount++;
                        return this.createFallbackContext(contextMode);
                    }
                }

                return context;
            }

            createFallbackContext(failedMode) {
                const fallbackOrder = ['webgl2', 'webgl', 'canvas2d', 'mock'];
                const currentIndex = fallbackOrder.indexOf(failedMode);
                
                for (let i = currentIndex + 1; i < fallbackOrder.length; i++) {
                    try {
                        return this.createContext(fallbackOrder[i]);
                    } catch (error) {
                        this.log('warning', `Fallback ${fallbackOrder[i]} failed`);
                        continue;
                    }
                }

                return this.createContext('mock');
            }

            createMockCanvas(width = 800, height = 600) {
                return {
                    width,
                    height,
                    style: {},
                    getContext: (type) => {
                        if (type === 'webgl' || type === 'webgl2') {
                            return this.createMockWebGLContext(this);
                        }
                        return this.createMock2DContext(this);
                    },
                    remove: () => {},
                    addEventListener: () => {},
                    removeEventListener: () => {}
                };
            }

            createMockWebGLContext(canvas) {
                return {
                    canvas,
                    isContextLost: () => false,
                    getParameter: (param) => {
                        const params = {
                            7936: 'Mock Software Renderer', // RENDERER
                            7937: 'Seiron Fallback System', // VENDOR
                            7938: 'WebGL 1.0 (Mock)', // VERSION
                        };
                        return params[param] || null;
                    },
                    getSupportedExtensions: () => ['WEBGL_lose_context'],
                    getExtension: (name) => {
                        if (name === 'WEBGL_lose_context') {
                            return {
                                loseContext: () => {},
                                restoreContext: () => {}
                            };
                        }
                        return null;
                    },
                    clear: () => {},
                    clearColor: () => {},
                    enable: () => {},
                    viewport: () => {}
                };
            }

            createMock2DContext(canvas) {
                return {
                    canvas,
                    clearRect: () => {},
                    fillRect: () => {},
                    arc: () => {},
                    fill: () => {},
                    stroke: () => {},
                    beginPath: () => {},
                    closePath: () => {}
                };
            }

            testThreeJS() {
                if (!this.currentContext) return false;

                try {
                    const scene = new THREE.Scene();
                    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                    
                    if (this.currentContext.type === 'webgl' || this.currentContext.type === 'webgl2') {
                        const renderer = new THREE.WebGLRenderer({
                            canvas: this.currentContext.canvas,
                            context: this.currentContext.context
                        });
                        renderer.render(scene, camera);
                        renderer.dispose();
                    }

                    return true;
                } catch (error) {
                    this.log('error', 'Three.js test failed', error);
                    return false;
                }
            }

            getDiagnostics() {
                return {
                    capabilities: this.capabilities,
                    currentContext: this.currentContext,
                    environment: {
                        isHeadless: this.isHeadless,
                        isDocker: this.isDocker,
                        userAgent: navigator.userAgent
                    },
                    performance: {
                        attemptCount: this.attemptCount,
                        lastInitTime: this.currentContext?.performance.initTime || 0
                    }
                };
            }

            dispose() {
                if (this.currentContext && this.currentContext.canvas && this.currentContext.canvas.remove) {
                    this.currentContext.canvas.remove();
                }
                this.currentContext = null;
                this.log('info', 'Manager disposed');
            }

            log(level, message, data) {
                const timestamp = new Date().toISOString();
                const logMessage = `[${timestamp}] ${level.toUpperCase()}: ${message}`;
                
                if (data) {
                    console[level === 'error' ? 'error' : 'log'](logMessage, data);
                } else {
                    console[level === 'error' ? 'error' : 'log'](logMessage);
                }
            }
        }

        // Simulated Diagnostics System
        class TestWebGLDiagnostics {
            constructor() {
                this.errorCount = 0;
                this.lastError = null;
                this.startTime = Date.now();
                this.performanceMetrics = [];
                this.memoryMetrics = [];
            }

            getDiagnosticInfo() {
                if (typeof window === 'undefined') {
                    return this.getHeadlessDiagnosticInfo();
                }

                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
                
                if (!gl) {
                    canvas.remove();
                    return this.getHeadlessDiagnosticInfo();
                }

                const info = {
                    renderer: gl.getParameter(gl.RENDERER),
                    vendor: gl.getParameter(gl.VENDOR),
                    version: gl.getParameter(gl.VERSION),
                    shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                    maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                    supportedExtensions: gl.getSupportedExtensions() || [],
                    timestamp: new Date()
                };

                canvas.remove();
                return info;
            }

            getHeadlessDiagnosticInfo() {
                return {
                    renderer: 'Software Renderer (Headless)',
                    vendor: 'Seiron Fallback System',
                    version: 'WebGL 1.0 (Mock)',
                    shadingLanguageVersion: 'WebGL GLSL ES 1.0 (Mock)',
                    maxTextureSize: 2048,
                    supportedExtensions: ['WEBGL_lose_context'],
                    timestamp: new Date()
                };
            }

            getHealthMetrics() {
                const isHeadless = typeof window === 'undefined';
                
                if (isHeadless) {
                    return {
                        isContextLost: false,
                        isContextAvailable: false,
                        renderingContextType: 'mock',
                        performanceScore: 50,
                        memoryUsage: 25,
                        errorCount: this.errorCount,
                        lastError: this.lastError,
                        uptime: Date.now() - this.startTime,
                        timestamp: new Date()
                    };
                }

                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
                
                const metrics = {
                    isContextLost: gl ? gl.isContextLost() : true,
                    isContextAvailable: !!gl,
                    renderingContextType: gl ? (
                        typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ? 'webgl2' : 'webgl'
                    ) : null,
                    performanceScore: this.calculatePerformanceScore(),
                    memoryUsage: this.calculateMemoryUsage(),
                    errorCount: this.errorCount,
                    lastError: this.lastError,
                    uptime: Date.now() - this.startTime,
                    timestamp: new Date()
                };

                canvas.remove();
                return metrics;
            }

            testCapabilities() {
                if (typeof window === 'undefined') {
                    return {
                        webgl: false,
                        webgl2: false,
                        headlessMode: true,
                        softwareRendering: true,
                        mockCanvas: true
                    };
                }

                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
                
                const capabilities = {
                    webgl: !!gl,
                    webgl2: !!(typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext),
                    canvas2d: !!canvas.getContext('2d'),
                    headlessMode: false,
                    softwareRendering: true,
                    mockCanvas: true
                };

                canvas.remove();
                return capabilities;
            }

            recordError(error) {
                this.errorCount++;
                this.lastError = error;
                console.error(`[Diagnostics] Error #${this.errorCount}: ${error}`);
            }

            calculatePerformanceScore() {
                if (this.performanceMetrics.length === 0) return 100;
                
                const average = this.performanceMetrics.reduce((sum, val) => sum + val, 0) / this.performanceMetrics.length;
                const targetFrameTime = 16.67;
                return Math.max(0, Math.min(100, 100 - ((average - targetFrameTime) * 2)));
            }

            calculateMemoryUsage() {
                if (typeof performance !== 'undefined' && 'memory' in performance) {
                    const memory = performance.memory;
                    return memory.usedJSHeapSize / 1024 / 1024;
                }
                return 25; // Default for headless
            }

            generateReport() {
                const diagnosticInfo = this.getDiagnosticInfo();
                const healthMetrics = this.getHealthMetrics();
                const capabilities = this.testCapabilities();

                return `WebGL Diagnostic Report
Generated: ${new Date().toISOString()}

=== HEALTH METRICS ===
Context Available: ${healthMetrics.isContextAvailable ? '✅' : '❌'}
Context Lost: ${healthMetrics.isContextLost ? '❌' : '✅'}
Rendering Context: ${healthMetrics.renderingContextType || 'None'}
Performance Score: ${healthMetrics.performanceScore.toFixed(2)}
Memory Usage: ${healthMetrics.memoryUsage.toFixed(2)} MB
Error Count: ${healthMetrics.errorCount}
Uptime: ${(healthMetrics.uptime / 1000).toFixed(2)}s

=== DIAGNOSTIC INFO ===
Renderer: ${diagnosticInfo.renderer}
Vendor: ${diagnosticInfo.vendor}
Version: ${diagnosticInfo.version}
Shading Language: ${diagnosticInfo.shadingLanguageVersion}
Max Texture Size: ${diagnosticInfo.maxTextureSize}

=== CAPABILITIES ===
${Object.entries(capabilities)
  .map(([key, value]) => `${key}: ${value ? '✅' : '❌'}`)
  .join('\n')}

=== SUPPORTED EXTENSIONS ===
${diagnosticInfo.supportedExtensions.join(', ')}`;
            }
        }

        // Initialize systems
        diagnosticsInstance = new TestWebGLDiagnostics();

        // Test functions
        window.testEnvironmentDetection = function() {
            const output = document.getElementById('environment-output');
            output.textContent = 'Testing environment detection...\n';

            const isHeadless = typeof window === 'undefined' || 
                             !window.chrome || 
                             !window.chrome.runtime || 
                             navigator.webdriver === true;
            
            const isDocker = window.location.hostname === 'localhost' && !window.devicePixelRatio;

            const results = {
                isHeadless,
                isDocker,
                userAgent: navigator.userAgent,
                vendor: navigator.vendor,
                platform: navigator.platform,
                devicePixelRatio: window.devicePixelRatio,
                screen: `${screen.width}x${screen.height}`,
                window: `${window.innerWidth}x${window.innerHeight}`,
                webglSupport: !!window.WebGLRenderingContext,
                webgl2Support: !!window.WebGL2RenderingContext
            };

            output.textContent += JSON.stringify(results, null, 2);
            testMetrics.environment = results;
            updateStatusIndicator('environment-output', !isHeadless ? 'success' : 'warning');
        };

        window.testHeadlessDetection = function() {
            const output = document.getElementById('environment-output');
            output.textContent += '\n\nTesting headless detection patterns...\n';

            const tests = {
                chromeRuntime: !!window.chrome?.runtime,
                webdriver: navigator.webdriver,
                userAgentHeadless: navigator.userAgent.includes('HeadlessChrome'),
                phantomJS: window._phantom || window.callPhantom,
                selenium: window.selenium,
                cdc: Object.keys(window).some(key => key.includes('cdc_')),
                webdriver2: window.navigator.webdriver,
                permissions: navigator.permissions?.query ? 'available' : 'missing'
            };

            output.textContent += JSON.stringify(tests, null, 2);
        };

        window.testCapabilityDetection = function() {
            const output = document.getElementById('capability-output');
            output.textContent = 'Testing capability detection...\n';

            try {
                if (!fallbackManager) {
                    fallbackManager = new TestWebGLFallbackManager();
                }

                const capabilities = fallbackManager.detectCapabilities();
                output.textContent += JSON.stringify(capabilities, null, 2);
                testMetrics.capabilities = capabilities;
                
                const hasWebGL = capabilities.webgl || capabilities.webgl2;
                updateStatusIndicator('capability-output', hasWebGL ? 'success' : 'warning');
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
                updateStatusIndicator('capability-output', 'error');
            }
        };

        window.testThreeJSCompatibility = function() {
            const output = document.getElementById('capability-output');
            output.textContent += '\n\nTesting Three.js compatibility...\n';

            try {
                // Test basic Three.js functionality
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
                const geometry = new THREE.BoxGeometry();
                const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const cube = new THREE.Mesh(geometry, material);
                
                scene.add(cube);
                
                // Test WebGL renderer if available
                try {
                    const canvas = document.createElement('canvas');
                    const renderer = new THREE.WebGLRenderer({ canvas });
                    renderer.render(scene, camera);
                    renderer.dispose();
                    canvas.remove();
                    
                    output.textContent += 'Three.js WebGL: ✅ Working\n';
                } catch (webglError) {
                    output.textContent += `Three.js WebGL: ❌ Failed (${webglError.message})\n`;
                }

                // Cleanup
                geometry.dispose();
                material.dispose();

                output.textContent += 'Three.js Core: ✅ Working\n';
                
            } catch (error) {
                output.textContent += `Three.js Core: ❌ Failed (${error.message})\n`;
            }
        };

        window.testFallbackManager = function() {
            const output = document.getElementById('manager-output');
            output.textContent = 'Creating fallback manager...\n';

            try {
                if (fallbackManager) {
                    fallbackManager.dispose();
                }

                fallbackManager = new TestWebGLFallbackManager({
                    enableSoftwareRendering: true,
                    enableCanvas2DFallback: true,
                    enableHeadlessMode: true,
                    enableMockCanvas: true,
                    logLevel: 'info'
                });

                const diagnostics = fallbackManager.getDiagnostics();
                output.textContent += JSON.stringify(diagnostics, null, 2);
                testMetrics.manager = diagnostics;
                updateStatusIndicator('manager-output', 'success');
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
                updateStatusIndicator('manager-output', 'error');
            }
        };

        window.testContextCreation = function() {
            const output = document.getElementById('manager-output');
            output.textContent += '\n\nTesting context creation...\n';

            if (!fallbackManager) {
                output.textContent += 'Error: Manager not initialized\n';
                return;
            }

            const modes = ['webgl2', 'webgl', 'canvas2d', 'mock'];
            
            modes.forEach(mode => {
                try {
                    output.textContent += `\nTesting ${mode} context...\n`;
                    const context = fallbackManager.createContext(mode);
                    output.textContent += `✅ ${mode}: ${context.type}\n`;
                    
                    if (mode === 'webgl' || mode === 'webgl2') {
                        const threeJSWorks = fallbackManager.testThreeJS();
                        output.textContent += `Three.js: ${threeJSWorks ? '✅' : '❌'}\n`;
                    }
                    
                } catch (error) {
                    output.textContent += `❌ ${mode}: ${error.message}\n`;
                }
            });
        };

        window.disposeFallbackManager = function() {
            const output = document.getElementById('manager-output');
            
            if (fallbackManager) {
                fallbackManager.dispose();
                fallbackManager = null;
                output.textContent += '\n\nManager disposed ✅\n';
                updateStatusIndicator('manager-output', 'info');
            } else {
                output.textContent += '\n\nNo manager to dispose\n';
            }
        };

        window.testMockWebGL = function() {
            const output = document.getElementById('mock-output');
            output.textContent = 'Testing mock WebGL context...\n';

            try {
                const mockManager = new TestWebGLFallbackManager();
                const mockCanvas = mockManager.createMockCanvas(400, 300);
                const mockGL = mockManager.createMockWebGLContext(mockCanvas);

                const tests = {
                    contextLost: mockGL.isContextLost(),
                    renderer: mockGL.getParameter(7936),
                    vendor: mockGL.getParameter(7937),
                    version: mockGL.getParameter(7938),
                    extensions: mockGL.getSupportedExtensions(),
                    loseContextExt: !!mockGL.getExtension('WEBGL_lose_context')
                };

                output.textContent += JSON.stringify(tests, null, 2);
                updateStatusIndicator('mock-output', 'success');
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
                updateStatusIndicator('mock-output', 'error');
            }
        };

        window.testMockCanvas = function() {
            const output = document.getElementById('mock-output');
            output.textContent += '\n\nTesting mock canvas...\n';

            try {
                const mockManager = new TestWebGLFallbackManager();
                const mockCanvas = mockManager.createMockCanvas(800, 600);
                const mock2D = mockManager.createMock2DContext(mockCanvas);

                const tests = {
                    canvasSize: `${mockCanvas.width}x${mockCanvas.height}`,
                    webglContext: !!mockCanvas.getContext('webgl'),
                    canvas2dContext: !!mockCanvas.getContext('2d'),
                    contextTypes: ['webgl', '2d'].map(type => ({
                        type,
                        available: !!mockCanvas.getContext(type)
                    }))
                };

                output.textContent += JSON.stringify(tests, null, 2);
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
            }
        };

        window.testSoftwareRenderer = function() {
            const output = document.getElementById('mock-output');
            output.textContent += '\n\nTesting software renderer...\n';

            try {
                if (!fallbackManager) {
                    fallbackManager = new TestWebGLFallbackManager();
                }

                const context = fallbackManager.createContext('mock');
                
                if (context.type === 'mock') {
                    output.textContent += '✅ Software renderer context created\n';
                    output.textContent += `Type: ${context.type}\n`;
                    output.textContent += `Headless: ${context.isHeadless}\n`;
                    output.textContent += `Docker: ${context.isDocker}\n`;
                } else {
                    output.textContent += `❌ Expected mock, got ${context.type}\n`;
                }
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
            }
        };

        window.testDiagnostics = function() {
            const output = document.getElementById('diagnostics-output');
            output.textContent = 'Running diagnostics...\n';

            try {
                const diagnosticInfo = diagnosticsInstance.getDiagnosticInfo();
                output.textContent += JSON.stringify(diagnosticInfo, null, 2);
                testMetrics.diagnostics = diagnosticInfo;
                updateStatusIndicator('diagnostics-output', 'success');
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
                updateStatusIndicator('diagnostics-output', 'error');
            }
        };

        window.testHealthMetrics = function() {
            const output = document.getElementById('diagnostics-output');
            output.textContent += '\n\nRunning health check...\n';

            try {
                const healthMetrics = diagnosticsInstance.getHealthMetrics();
                output.textContent += JSON.stringify(healthMetrics, null, 2);
                testMetrics.health = healthMetrics;
                
                const isHealthy = healthMetrics.isContextAvailable && !healthMetrics.isContextLost;
                updateStatusIndicator('diagnostics-output', isHealthy ? 'success' : 'warning');
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
                updateStatusIndicator('diagnostics-output', 'error');
            }
        };

        window.generateReport = function() {
            const output = document.getElementById('diagnostics-output');
            output.textContent += '\n\nGenerating full report...\n';

            try {
                const report = diagnosticsInstance.generateReport();
                output.textContent += '\n' + report;
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
            }
        };

        window.simulateContextLoss = function() {
            const output = document.getElementById('recovery-output');
            output.textContent = 'Simulating context loss...\n';

            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                
                if (gl) {
                    const loseContextExt = gl.getExtension('WEBGL_lose_context');
                    if (loseContextExt) {
                        loseContextExt.loseContext();
                        output.textContent += '✅ Context loss simulated\n';
                        
                        setTimeout(() => {
                            loseContextExt.restoreContext();
                            output.textContent += '✅ Context restored\n';
                            updateStatusIndicator('recovery-output', 'success');
                        }, 2000);
                    } else {
                        output.textContent += '❌ WEBGL_lose_context extension not available\n';
                        updateStatusIndicator('recovery-output', 'warning');
                    }
                } else {
                    output.textContent += '❌ WebGL context not available\n';
                    updateStatusIndicator('recovery-output', 'error');
                }
                
                canvas.remove();
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
                updateStatusIndicator('recovery-output', 'error');
            }
        };

        window.testAutoRecovery = function() {
            const output = document.getElementById('recovery-output');
            output.textContent += '\n\nTesting auto-recovery...\n';

            try {
                if (!fallbackManager) {
                    fallbackManager = new TestWebGLFallbackManager();
                }

                // Simulate failure and recovery
                const originalContext = fallbackManager.createContext('webgl');
                output.textContent += `Original context: ${originalContext.type}\n`;

                // Force fallback
                const fallbackContext = fallbackManager.createFallbackContext('webgl');
                output.textContent += `Fallback context: ${fallbackContext.type}\n`;

                updateStatusIndicator('recovery-output', 'success');
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
                updateStatusIndicator('recovery-output', 'error');
            }
        };

        window.testErrorHandling = function() {
            const output = document.getElementById('recovery-output');
            output.textContent += '\n\nTesting error handling...\n';

            try {
                // Test various error scenarios
                const errors = [
                    'Simulated WebGL context creation failure',
                    'Simulated Three.js initialization error',
                    'Simulated shader compilation failure'
                ];

                errors.forEach((error, index) => {
                    diagnosticsInstance.recordError(error);
                    output.textContent += `Error ${index + 1}: ${error}\n`;
                });

                const healthAfterErrors = diagnosticsInstance.getHealthMetrics();
                output.textContent += `\nError count: ${healthAfterErrors.errorCount}\n`;
                output.textContent += `Last error: ${healthAfterErrors.lastError}\n`;

                updateStatusIndicator('recovery-output', 'warning');
                
            } catch (error) {
                output.textContent += '\nError: ' + error.message;
                updateStatusIndicator('recovery-output', 'error');
            }
        };

        // Status monitoring
        window.startMonitoring = function() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
            }

            monitoringInterval = setInterval(() => {
                updateStatusMonitor();
            }, 1000);

            updateStatusMonitor();
        };

        window.stopMonitoring = function() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
            }
        };

        window.clearMetrics = function() {
            testMetrics = {};
            document.getElementById('metrics-tbody').innerHTML = '';
        };

        function updateStatusMonitor() {
            const tbody = document.getElementById('metrics-tbody');
            const now = new Date().toLocaleTimeString();

            const metrics = [
                { name: 'WebGL Available', value: !!document.createElement('canvas').getContext('webgl'), status: 'info' },
                { name: 'WebGL2 Available', value: !!document.createElement('canvas').getContext('webgl2'), status: 'info' },
                { name: 'Three.js Loaded', value: typeof THREE !== 'undefined', status: 'success' },
                { name: 'Fallback Manager', value: !!fallbackManager, status: fallbackManager ? 'success' : 'warning' },
                { name: 'Memory Usage', value: getMemoryUsage() + ' MB', status: 'info' },
                { name: 'Error Count', value: diagnosticsInstance.errorCount, status: diagnosticsInstance.errorCount > 0 ? 'warning' : 'success' }
            ];

            tbody.innerHTML = metrics.map(metric => `
                <tr>
                    <td>${metric.name}</td>
                    <td>${metric.value}</td>
                    <td><span class="status-indicator ${metric.status}"></span>${metric.status}</td>
                    <td>${now}</td>
                </tr>
            `).join('');
        }

        function getMemoryUsage() {
            if (typeof performance !== 'undefined' && 'memory' in performance) {
                return (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
            }
            return 'N/A';
        }

        function updateStatusIndicator(outputId, status) {
            const panel = document.getElementById(outputId).closest('.test-panel');
            const indicator = panel.querySelector('.status-indicator');
            indicator.className = `status-indicator ${status}`;
        }

        // Initialize
        document.getElementById('load-status').textContent = '✅ Utilities loaded successfully';
        
        // Auto-start basic tests
        setTimeout(() => {
            testEnvironmentDetection();
            testCapabilityDetection();
            startMonitoring();
        }, 500);
    </script>
</body>
</html>